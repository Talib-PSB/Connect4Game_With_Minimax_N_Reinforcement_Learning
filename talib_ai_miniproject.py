# -*- coding: utf-8 -*-
"""Talib_AI_Miniproject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F-eUW4ee3_q4-0Sh-RAQxRNwIlKlIcx-
"""

import numpy as np
import random
import math

# NAME :ABDUL TALIB BIN RASAK
# STUDENT ID : 040F47EN(PSB), 22037473(UH)

ROW_NUMBER = 6
COLUMN_NUMBER = 7

player = 0
computer = 1

PLAYER_BALL = 1
COMPUTER_BALL = 2

WINDOW_LENGTH = 4
EMPTY = 0

# creation of board with zero elements inside. Size 6 rows & 7 columns
def create_board():
  board = np.zeros((6,7))
  return board

# This function emulates the ball drop in columns
def drop_ball(board,row_selection,column_selection,ball):
  board[row_selection][column_selection] = ball

# Here we check to make sure column is empty
def check_for_valid_location(board,column_selection):
  return board[ROW_NUMBER-1][column_selection] == 0

# Here, we are checking if rows are empty
def get_next_open_row(board, column_selection):
  for r in range(ROW_NUMBER):
    if board[r][column_selection] == 0:
      return r

#This function flips the board upside down flip is from numpy
def print_board(board):
    print(np.flip(board,0))

#This function checks for who is the winner!
def winner_player(board,ball):
  #check for horizontal win
  for c in range(COLUMN_NUMBER-3):
    for r in range(ROW_NUMBER):
      if board[r][c] == ball and board[r][c+1] == ball and board[r][c+2]== ball and board[r][c+3] == ball:
        return True

  #Check for vertical win
  for c in range(COLUMN_NUMBER):
    for r in range(ROW_NUMBER-3):
      if board[r][c] == ball and board[r+1][c] == ball and board[r+2][c] == ball and board[r+3][c] == ball:
        return True

  # Check positively sloped diaganols
  for c in range(COLUMN_NUMBER-3):
    for r in range(ROW_NUMBER-3):
      if board[r][c] == ball and board[r+1][c+1] == ball and board[r+2][c+2] == ball and board[r+3][c+3] == ball:
        return True

  # Check negatively sloped diaganols
  for c in range(COLUMN_NUMBER-3):
    for r in range(3, ROW_NUMBER):
      if board[r][c] == ball and board[r-1][c+1] == ball and board[r-2][c+2] == ball and board[r-3][c+3] == ball:
        return True

#This function looks for valid moves
def get_valid_location(board):
    valid_location = []
    for column_selection in range(COLUMN_NUMBER):
        if check_for_valid_location(board,column_selection):
            valid_location.append(column_selection)

    return valid_location

# medium level difficulty technique
def score_method(board,ball):
    score = 0

    #horizontal score
    for r in range(ROW_NUMBER):
        row_array = [int(i) for i in list(board[r,:])]
        for c in range(COLUMN_NUMBER-3):
            window = row_array[c:c+WINDOW_LENGTH]
            if window.count(ball) == 4:
                score += 100
            elif window.count(ball) == 3 and window.count(EMPTY) == 1:
                score += 10
            elif window.count(ball) == 2 and window.count(EMPTY) == 2:
                score += 5
            if window.count(PLAYER_BALL) == 3 and window.count(EMPTY) == 1:
                score -= 50

    #vertical score
    for c in range(COLUMN_NUMBER):
        column_array = [int(i) for i in list(board[:,c])]
        for r in range(ROW_NUMBER-2):
            window = column_array[r:r+WINDOW_LENGTH]
            if window.count(ball) == 4:
                score += 100
            elif window.count(ball) == 3 and window.count(EMPTY) == 1:
                score += 10
            elif window.count(ball) == 2 and window.count(EMPTY) == 2:
                score += 5
            if window.count(PLAYER_BALL) == 3 and window.count(EMPTY) == 1:
                score -= 50

    ## Score posiTive sloped diagonal
    for r in range(ROW_NUMBER-3):
	    for c in range(COLUMN_NUMBER-3):
	        window = [board[r+i][c+i] for i in range(WINDOW_LENGTH)]
	        if window.count(ball) == 4:
	            score += 100
	        elif window.count(ball) == 3 and window.count(EMPTY) == 1:
	            score += 5
	        elif window.count(ball) == 2 and window.count(EMPTY) == 2:
	            score += 2
	        if window.count(PLAYER_BALL) == 3 and window.count(EMPTY) == 1:
	            score -= 50

    ## Score negative slope diagonal
    for r in range(ROW_NUMBER-3):
        for c in range(COLUMN_NUMBER-3):
            window = [board[r+3-i][c+i] for i in range(WINDOW_LENGTH)]
            if window.count(ball) == 4:
	            score += 100
            elif window.count(ball) == 3 and window.count(EMPTY) == 1:
	            score += 5
            elif window.count(ball) == 2 and window.count(EMPTY) == 2:
                score += 2
            if window.count(PLAYER_BALL) == 3 and window.count(EMPTY) == 1:
                score -= 50

    return score

# pick best move for medium difficulty
def pick_best_move(board,ball):
    valid_location = get_valid_location(board)
    best_score = -10000
    best_column = random.choice(valid_location)
    for column_selection in valid_location:
        row_selection = get_next_open_row(board,column_selection)
        temp_board = board.copy()
        drop_ball(temp_board,row_selection,column_selection,ball)
        score = score_method(temp_board,ball)
        if score > best_score:
            best_score = score
            best_column = column_selection

    return best_column


#Minimax algorithm starts here. Difficulty level 3
def terminal_node_state(board):
    return winner_player(board, PLAYER_BALL) or winner_player(board,COMPUTER_BALL) or len(get_valid_location(board)) == 0

def minimax(board,depth,maximizingPlayer):
    valid_location = get_valid_location(board)
    terminal_node = terminal_node_state(board)
    if depth == 0 or terminal_node:
            if terminal_node:
                if winner_player(board, COMPUTER_BALL):
                    return (None, 1000000000000)
                elif winner_player(board, PLAYER_BALL):
                    return (None, -1000000000000)
                else: # Game is over, no more valid moves
                    return (None, 0)
            else: # Depth is zero
                return (None, score_method(board, COMPUTER_BALL))

    if maximizingPlayer:
        value = -math.inf
        column = random.choice(valid_location)
        for column_selection in valid_location:
            row_selection = get_next_open_row(board,column_selection)
            b_copy = board.copy()
            drop_ball(b_copy, row_selection, column_selection, COMPUTER_BALL)
            new_score = minimax(b_copy, depth-1,False)[1]
            if new_score > value:
                value = new_score
                column = column_selection
        return column,value

    else:   #MinimisingPlayer
        value = math.inf
        for column_selection in valid_location:
            row_selection = get_next_open_row(board, column_selection)
            b_copy = board.copy()
            drop_ball(b_copy,row_selection, column_selection, PLAYER_BALL)
            new_score = minimax(b_copy, depth-1,True)[1]
            if new_score < value:
                value = new_score
                column = column_selection
        return column, value

# GAME MAIN LOOP STARTS HERE
player_name = input("Hello, what is your name? :")
print(player_name + " Let's play Connect 4")

cont = 'Y'
while cont == 'Y':
  board = create_board()
  flag = True
  difficulty = 0 # error checking of difficulty level starts
  while flag:
    try:
        difficulty = int(input("Please enter difficulty level (1=easy,2=medium,3=hard)"))
    except ValueError:
        print("Please input a valid number")
    if  difficulty in [1,2,3]:
        flag = False
  game_over = False
  turn = random.randint(0,1)
  while not game_over:
    #ask player 1 & computer input
    if turn == player:
        flag2 = True #error checking for column input
        while flag2:
            try:
                column_selection = int(input(player_name + " ,Please input your selection (columns 0-6)"))
                if column_selection not in range(0,7):
                    print("number out of range!Please enter from 0-6")
            except ValueError:
                print("This is not a number.Try again.")
            if column_selection in [0,1,2,3,4,5,6]:
                flag2 = False
        if check_for_valid_location(board, column_selection):
            row_selection = get_next_open_row(board,column_selection)
            drop_ball(board,row_selection,column_selection,PLAYER_BALL)

        if winner_player(board,PLAYER_BALL):
          print("Hooray! You win! Congratulations")
          game_over = True

        print_board(board)
        turn += 1
        turn = turn % 2

    if turn == computer and not game_over:
        if difficulty == 1:
            column_selection = random.randint(0,COLUMN_NUMBER - 1)
        elif difficulty == 2:
            column_selection = pick_best_move(board,COMPUTER_BALL)
        else:
            column_selection, minimax_score = minimax(board,3,True)
        print("Computer decided column", column_selection)
        if check_for_valid_location(board,column_selection):
            row_selection = get_next_open_row(board,column_selection)
            drop_ball(board,row_selection,column_selection,COMPUTER_BALL)
        if winner_player(board,COMPUTER_BALL):
          print("You Lose! Computer Wins")
          game_over = True

        print_board(board)
        turn += 1
        turn = turn % 2

  cont = input("Do you wish to play again? Y/N \n")
  cont = cont.upper() #error handling

print("Thanks for playing! ")